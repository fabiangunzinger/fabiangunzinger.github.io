[{"categories":["growth"],"content":"My wife and I are about to become parents for the first time. In this space, I want to collect a limited number of core pieces of advice I want to remember. They are all from Philippa Perry’s wonderful book The book you wish your parents had read, which I can’t recommend highly enough to any parent. Stuff I want to remember: A child is not a thing I need to manage and train to behave well, but an individual I’m building a relationship with. All behaviour is communication. Instead of reacting to the behaviour, try to understand the feelings or needs that cause it, and help my child identify and articulate them, so that they learn doing it themselves. To help me do that, I want to get into the habit of seeing the world from my child’s perspective. I want to be a container for my child’s feelings – to accept all their feelings, validate them, and help them identify and express them. I want to talk to my child about what is going to happen so they can mentally prepare for it instead of just having things done to them. I want to praise them for effort, not achievements, and be curious about how they feel, instead of telling them how they should feel and how I feel about things they do. I want to remember that strong emotional reactions to my child’s behaviour are likely to be a reaction to my own past. In such moments I want to ask myself what used to happen to me as a child when I behaved in this way. I want to talk about my child as the individual they are, not as “the child” or – worse – “the children”. I want to poblem-solve with them, not for them: to not rescue them unnecessarily, but help them solve their own problems as needed; to be a sounding board, not an oracle. I want to invest positive time early instead of negative time later. ","date":"2023-05-14","objectID":"/parenting-principles/:0:0","tags":["parenting"],"title":"Parenting advice I want to remember","uri":"/parenting-principles/"},{"categories":null,"content":"Formatted string literals (f-strings) A basic f-string consists of a combination of literal characters and replacement characters, the latter of which are placed inside braces (full grammar here, useful explanation of how they are parsed here). The general form for the replacement field is \"{\" expression [\"=\"] [\"!\" conversion] [\":\" format_spec] \"}\". name = \"world\" f\"Hello {name}\" 'Hello world' Add = to also print the name of the replacement expression (useful for debugging). name = \"world\" f\"Hello {name=}\" \"Hello name='world'\" Add a ! for conversion: !s calls str(), !r calls repr(), and !a calls ascii(). name = \"world\" f\"Hello {name!r}\" \"Hello 'world'\" Add : to add a format specifier, using the format mini language. import datetime today = datetime.datetime.today() f\"It's {today:%H.%M} on {today:%d %B, %Y.}\" \"It's 06.45 on 01 December, 2021.\" Expressions can be nested (it’s a contrived example, we could just used %p to get AM and PM) f\"It's {today:%H.%M{'am' if today.hour \u003c 12 else 'pm'}} on {today:%d %B, %Y.}\" \"It's 06.45am on 01 December, 2021.\" value = 5.123 width = 5 precision = 2 f\"{value:{width}.{precision}}\" ' 5.1' Backslashes are not allowed in expressions. If I need backslash escapes, use a variable. newline = ord(\"\\n\") f\"newline: {newline}\" 'newline: 10' ","date":"2021-09-11","objectID":"/python-string-formatting/:1:0","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Format specifier form The general form of the format specifier is (docs): [[fill]align][sign][#][0][width][grouping_option][.precision][type] where: fill: any character align: \u003c, \u003e, ^ (right, left, centered alignment), = (sign-aware zero padding, see below) sign: + (show positive and negative sign), - (show negative sign only, default), space (show space for positive numbers and minus sign for negative ones) #: user “alternate form” for conversion. Effect depends on type. Prevents removal of trailing zeroes in g and G conversion (see below) grouping_option: ,, _, n (comma, underscore, locale aware thousands separator) 0: Turns on sign-aware zero padding (equivalent to 0 fill character with = alignment, see below) .precision: number of digits after decimal points for f or F formatted floats, before and after decimal point for g or G formatted floats, and number of characters used for non-numeric types. type: see below. ","date":"2021-09-11","objectID":"/python-string-formatting/:2:0","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Types The type determines how the data should be presented. ","date":"2021-09-11","objectID":"/python-string-formatting/:3:0","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"String types The only available type is s for string format, which is the default and can be omitted. s = \"Hello World.\" f\"{s}\", f\"{s:s}\" ('Hello World.', 'Hello World.') ","date":"2021-09-11","objectID":"/python-string-formatting/:3:1","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Integer types The default is d for decimal integer, which represents the integer in base 10. This is pretty much all I ever need. But the below also shows examples of how to prepresent an integer in bases two (b for binary), eight (o for octal), and sixteen (x for hexadecimal). There are also a few more options available. n = 10 f\"{n:d}\", f\"{n:b}\", f\"{n:o}\", f\"{n:x}\" ('10', '1010', '12', 'a') ","date":"2021-09-11","objectID":"/python-string-formatting/:3:2","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Float (and integer) types (Much of this also applies to decimals, which provide a solution to minor rounding issues that happen with floats. But I’ve never needed them and ignore them for now.) e produces scientific notation with one digit before and precision digits after the decimal point for a total of 1 + precision significant digits. precision defaults to 6. E is the same but uses an upper case E as a separator. n = 01234.56789 precision = 0.3 f\"{n:e}\", f\"{n:{precision}e}\", f\"{n:{precision}E}\" ('1.234568e+03', '1.235e+03', '1.235E+03') f produces fixed-point notation with precision number of digits after the decimal point. precision defaults to 6. F is the same but converts nan to NAN and inf to INF. f\"{n:f}\", f\"{n:{precision}f}\" ('1234.567890', '1234.568') g produces general format with precision number of significant digits and the number formatted either using fixed-point or scientific notation depending on its magnitude. precision defaults to 6. G has the same behaviour as F and converts large numbers to scientific notation. (In the last example, remember that the high precision doesn’t add zero padding because it determines the number of significant digits.) f\"{n:g}\", f\"{n:.1g}\", f\"{n:.3g}\", f\"{n:.12g}\" ('1234.57', '1e+03', '1.23e+03', '1234.56789') The below might be unexpected (it was for me, anyways). It is a result of the fact that decimals can’t be represented exactly in binary floating point. The right-hand side expression represents another example of the same limitation. If such high precision is needed, the decimal module should help. f\"{n:.25g}\", 1.1 + 2.2 ('1234.567890000000033978722', 3.3000000000000003) % produces a percentage by multiplying the number by 100, adding a percent sign, and formatting the number using fixed-point format (e.g. the default is 6 “precision digits” after the decimal point). f\"{n:%}\", f\"{n:.2%}\" ('123456.789000%', '123456.79%') ","date":"2021-09-11","objectID":"/python-string-formatting/:3:3","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Strings .precision determines the number of characters used. text = \"Hello World!\" f\"{text:.^30.5}\" '............Hello.............' ","date":"2021-09-11","objectID":"/python-string-formatting/:3:4","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Digits By convention, an empty format field produces the same result as calling str() on the value. n = 01234.56789 f\"{n:}\", str(n) ('1234.56789', '1234.56789') By default, the width equals the length of the data, so fill and align have no effect. f\"{n:@\u003c}\" '1234.56789' We can use = alignment to add padding between the sign and the digit, and use a 0 before width as a shortcut to get sign-aware zero padding (i.e. the equivalent of a 0 fill with = alignment). f\"{n:=+15}\", f\"{n:0=+15}\", f\"{n:+015}\" ('+ 1234.56789', '+00001234.56789', '+00001234.56789') Use # to keep trailing zeroes in g and G conversions. f\"{123.400:g}\", f\"{123.400:#g}\" ('123.4', '123.400') Thousands separators. n = 1_000_000 f\"{n:,}\", f\"{n:_}\", f\"{n:n}\" ('1,000,000', '1_000_000', '1000000') ","date":"2021-09-11","objectID":"/python-string-formatting/:3:5","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Character sets The string module (docs here) provides a set of useful character sets as module constants. import string string.ascii_lowercase 'abcdefghijklmnopqrstuvwxyz' string.ascii_letters 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' string.digits '0123456789' string.punctuation '!\"#$%\u0026\\'()*+,-./:;\u003c=\u003e?@[\\\\]^_`{|}~' ","date":"2021-09-11","objectID":"/python-string-formatting/:4:0","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Dates Quick reference for strftime() and strptime() codes I use often and keep forgetting. Full list here. (As a reminder: strftime() is an instance method that converts datetime objects to a string in a given format, while strptime() is a class method that parses a string and converts it to datetime.) import datetime today = datetime.datetime.today() print(today) 2021-12-01 06:36:20.652838 fmt = \"%d %b %Y\" today.strftime(fmt), datetime.datetime.strptime(\"1 Dec 2021\", fmt) ('01 Dec 2021', datetime.datetime(2021, 12, 1, 0, 0)) today.strftime(\"%y %Y\") '21 2021' today.strftime(\"%a %A\") 'Wed Wednesday' today.strftime(\"%b %B\") 'Dec December' print(today.strftime(\"%H:%M:%S\")) # 24-hour clock print(today.strftime(\"%I:%M%p\")) # 12-hour clock 06:36:20 06:36AM today.strftime(\"%c || %x || %X\") # Locale's appropriate formatting and literals 'Wed Dec 1 06:36:20 2021 || 12/01/21 || 06:36:20' ","date":"2021-09-11","objectID":"/python-string-formatting/:5:0","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Applications ","date":"2021-09-11","objectID":"/python-string-formatting/:6:0","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"string doc examples Accessing argument’s items point = (2, 5) \"x = {0[0]}, y = {0[1]}\".format(point) 'x = 2, y = 5' Using format mini-language n = 10000 \"{:.\u003e20,.2f}\".format(n) '...........10,000.00' Formatting dates import datetime today = datetime.datetime.today() print(\"Day: {date:%d}\\nMonth: {date:%b}\\nYear: {date:%Y}\".format(date=today)) Day: 07 Month: Dec Year: 2021 ","date":"2021-09-11","objectID":"/python-string-formatting/:6:1","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Create table from list of tuples Based on example from page 29 in Fluent Python. Code is available here. metro_areas = [ (\"Tokyo\", \"JP\", 36.933, (35.689722, 139.691667)), (\"Delhi NCR\", \"IN\", 21.935, (28.613889, 77.208889)), (\"Mexico City\", \"MX\", 20.142, (19.433333, -99.133333)), (\"New York-Newark\", \"US\", 20.104, (40.808611, -74.020386)), (\"Sao Paulo\", \"BR\", 19.649, (-23.547778, -46.635833)), ] hline, hhline = \"-\" * 39, \"=\" * 39 print(hhline) print(\"{:15} | {:^9} | {:^9}\".format(\" \", \"lat.\", \"long.\")) print(hline) fmt = \"{:15} | {:\u003e9.4f} | {:\u003e9.4f}\" for name, cc, pop, (lat, long) in metro_areas: if long \u003c= 0: print(fmt.format(name, lat, long)) print(hhline) ======================================= | lat. | long. --------------------------------------- Mexico City | 19.4333 | -99.1333 New York-Newark | 40.8086 | -74.0204 Sao Paulo | -23.5478 | -46.6358 ======================================= ","date":"2021-09-11","objectID":"/python-string-formatting/:6:2","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":null,"content":"Main sources string docs Formatted string literals docs Fluent Python Python Cookbook ","date":"2021-09-11","objectID":"/python-string-formatting/:7:0","tags":["python"],"title":"Python string formatting","uri":"/python-string-formatting/"},{"categories":["craft"],"content":"Preliminaries I use neovim. My configuration is here. There, I map \u003cesc\u003e to jk, a mapping I also use throughout this file. I’ve remaped Caps Look to \u003cctrl\u003e on my mac. ","date":"2021-09-11","objectID":"/vim/:1:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Quarto setup \u003cshift-k\u003e to open help on object under cursor, \u003cshift-kk\u003e to ender help window, q to quit help. Terminal: open new terminal with \u003cleader\u003ec, then activate terminal by going into insert mode and going back to normal mode with usual keybinding. ","date":"2021-09-11","objectID":"/vim/:2:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Reminders git-gutter: ]h and [h to jump to next and previous hunk, \u003cleader\u003ehs and \u003cleader\u003ehu to stage and unstage hunk. Vim takes an additional command on startup (e.g. nvim +CommandT). Use one keystroke to move and one to execute (e.g. the dot-formula). Exit and re-enter insert mode strategically to chunk your undos (all changes in a single insert session count as one change). If you hit cursor keys more than 2 or 3 times, press backspace more than a couple times, perform the same change on several lines, there is a better way. I want to open a file and get an E325: ATTENTION Found a swap file warning. What happened? For me, it’s most likely that I accidentally closed a terminal window while still editing the file. What to do? First, check that I’m not already editing the file elsewhere. Second, recover the file, save it under a new name (:w filename2), force quit the session, compare the original and the new file (diff filename filename2), use the file with the content I need and delete the other one and the swap file. (Based on this great SE answer.) Don’t solve a problem unless you come across it frequently (and if you do, check whether one of Tim Pope’s plugins solves it). Useful stuff I tend to forget: Command Effect \u003cC-f\u003e/\u003cC-b\u003e Scroll down/up screen-wise (“forwards-backwards”) c-x c-e In command line: edit current line in vim, run after quit :x Like :wq but only write if file was changed set: {option}? Show present setting for {option} set: {option}\u0026 Set option back to default value | Command separator (equivalent to ; in shell) \u003cc-k\u003e-N Enter en dash in insert mode using digraphs \u003cc-o-o\u003e After opening vim, opens last file with cursor at last edit :scriptnames List of scripts loaded on startup :map, :nmap, … Show existing mappings \u003cc-o\u003e / \u003cc-i\u003e To move back and forth in the jumplist ","date":"2021-09-11","objectID":"/vim/:3:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Help Command Effect gO Show table of contents for current help file :helpc[lose] Close help windows if any are open :vert h {keyword} Open help in a vertical split ","date":"2021-09-11","objectID":"/vim/:4:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Modes ","date":"2021-09-11","objectID":"/vim/:5:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Normal mode Operators work as follows: operator + [count] + motion = action. E.g. d2l deletes two character to the right, diw the word under the cursor (without the surrounding whitespace), dap the current paragraph (including the surrounding whitespace). Similarly, gUap converts the current paragraph to uppercase. Common operators: Trigger Effect c Change d Delete into register d Delete into register y Yank into register p Paste after cursor P Paste before cursor ~ Swap case of character under cursor and move right gu Make lowercase gU Make uppercase g~ Swap case \u003e Shift right \u003c Shift left = Autoindent ! Filter {motion} lines through an external program Moving back and forth: Forwards Backwards Effect / ? Seach for pattern * # Search for word under cursor n N Jump to next search match $ ^ Jump to end of line f{char} F{char} Position cursor on character t{char} T{char} Position cursor before character ; , Repeat the last r, F, t, or T w b Move to the start of the next word W B Move to the start of the next WORD } { Move down one (blank-line-separated) paragraph gg Jump to the first line of the document G Jump to the last line of the document Act, repeat, reverse: Intent Act Repeat Reverse Make a change {edit} . u Scan line for next character f{char}/t{char} ; , Scan line for previous character F{char}/T{char} ; , Scan document for next match /pattern\u003cCR\u003e n N Scan document for previous match ?pattern\u003cCR\u003e n N Perform substitution :s/old/new \u0026 u Execute a sequence of changes qx{change}q @x u Compound commands: Compound command Equivalent in longhand C c$ (delete from cursor until end of line and start insert) D d$ (delete from cursor until end of line) Y y$ (similar to above, but has to be mapped, see h: Y) s cl (delete single character and start insert) S ^c (delete entire line and start inster, synonym for cc) x dl (delete one character to the right) X dh (delete one character to the left) I ^i (jump to beginning of line and start insert) A $a (jumpt to end of line and start insert) o A\u003ccr\u003e O ko Miscellaneous: Command Effect \u003cC-a\u003e/ \u003cC-x\u003e Add / subtract from the next number \u003cC-o\u003e/ \u003cC-i\u003e Move backwards to last / forward to previous location u/\u003cC-r\u003e Undo / redo change ga Reveal numeric representation of character under cursor gx Open url under cursor \u003cC-z\u003e/fg Put vim in background / return to vim ","date":"2021-09-11","objectID":"/vim/:5:1","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Insert mode Entering insert mode: Trigger Effect i Insert before cursor a Insert after cursor I Insert at beginning of current line A Insert at end of current line o Insert in a new line below the current one O Insert in a new line above the current one gi Insert at the end of last insert Useful commands: Keystroke action \u003cc-h\u003e delete back one character (backspace) \u003cc-w\u003e delete back one word \u003cc-u\u003e delete back one line \u003cc-o\u003e Enter insert normal mode to execute a single normal cmd \u003cC-r\u003e{register} Paste content from address (use 0 for last yanked text) \u003cC-r\u003e= Perform calculation in place r, R Enter replace mode for single replacement or until exit \u003cC-v\u003e{123} Insert character by decimal code \u003cC-v\u003eu{1234} Insert character by hexadecimal code \u003cC-v\u003e{char1}{char2} Insert character by digraph ","date":"2021-09-11","objectID":"/vim/:5:2","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Visual mode Once in visual mode, you can use any normal mode movement command to specify the area to be selected. Reminder to myself: use search more often for this. Command Effect v Enter character-wise visual mode / back to normal mode V Enter line-wise visual mode / back to normal mode \u003cC-v\u003e Enter block-wise visual mode / back to normal mode gv Reselect last visual selection o Toggle the free end of a selection Exercises: Turn the list of objects into dictionary elements as shown. foo bar baz buzz d[0] = “foo” d[1] = “bar” d[2] = “baz” d[3] = “buzz” Solutions: yip to select paragraph, :s/\\(.*\\)/d[0] = \"\\1\" to replace each line with dict entry, then move to 0 in last paragraph, then \u003cc-v\u003eg\u003cc-a\u003e to activate block visual mode, and increment the lines. ","date":"2021-09-11","objectID":"/vim/:5:3","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Command-line mode Ex-commands allow you to make changes (in multiple places) anywhere in the file without moving the cursor – “they strike far and wide”. The general syntax is :[range]{command}, where [range] is either a single address or a range of addresses of the form {start},{stop}. There are three types of addresses: line numbers, visual selections, and patterns. To execute a command on all selected lines, use visual mode to make the selection and press :. This will start the command prompt with '\u003c, '\u003e:, to which you can then add the command. You can also specify offsets. For example, :/\u003ctag\u003e/+1\u003c\\/tag\u003e/-1{cmd} would operate on the lines inside the html tag but not the lines containing the tag marks. Command mode commands: Command Effect :, /, ? Opens command line / search /reverse search mode \u003cC-r\u003e\u003cC-w\u003e Insert word under cursor in command prompt \u003cleft\u003e/\u003cright\u003e Move one character left or right \u003cS-left\u003e Move one word left (similar for right) \u003cC-b\u003e/\u003cC-e\u003e Move to the beginning/end of the command \u003cC-w\u003e Delete last word \u003cC-u\u003e Delete from cursor to beginning of line Types of addresses: Command Effect :4{cmd} execute command on line 4 :4,8{cmd} execute command on lines 4 to 8 (inclusive) :/#/{cmd} execute command on next line with an # :/\u003ctag\u003e/\u003c\\/tag\u003e/{cmd} Execute command on next occurring html tag :'\u003c,'\u003e{cmd} Execute command on selected lines Useful address/range characters: Symobol Address 1 First line of the file $ Last line of the file 0 Virtual line above first line (e.g. to paste to top of file) . Line of cursor 'm Line containing mark m '\u003c Start of visual selection '\u003e End of visual selection % The entire file (short for :1,$) Common Ex-commands: Command Effect p[rint] Print d[elete] Delete j[oin] Join lines s[ubstitute] Substitute (e.g. s/old/new) n[ormal] Execute normal mode command m[ove] Move to {address}, (e.g. :1,5m$ moves lines to end of file) co[py] (or t) Copy to {address}, (e.g. :6t. copies line 6 to current line) Exercises: Wrap all elements in the first column of a table in quotes. Replace the word under the cursor throughout the file. Open help for word under the cursor. Solutions: With cursor on word in first row: :{start},{stop}normal ysaW'. *,cw{change}jk, :%s//\u003cC-r\u003e\u003cC-w\u003e/\u003coptions\u003e. :h \u003cC-r\u003e\u003cC-w\u003e\u003cCR\u003e. ","date":"2021-09-11","objectID":"/vim/:5:4","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Quickfix List The quickfix list is a special mode to speed up the edit-compile-edit cycle. But it can be used more generally to find a list of positions in files (e.g. list could hold search matches from running :vimgrep). The Location list is a local version of the quickfix list that is bound to the currently active window. There can be as many local lists as there are windows, while there is only a single globally available quickfix list. Command Effect :make [target] Compile target (and jump to first error if there are some) :make! [target] Compile target without jumping to first error :copen Open quickfix window :cclose Close quickfix window ]q / [q Jump to next/previous match (uses vim-unimpaired plugin) ","date":"2021-09-11","objectID":"/vim/:6:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Files Setting the working directory: Command Effect :pwd Show current directory window :cd Set directory for all windows :cd - Revert back to previous directory :lcd Set directory for current window :tcd Set directory for current tab ","date":"2021-09-11","objectID":"/vim/:7:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Buffers A buffer is an in-memory representation of a file. A hidden buffer is one that contains changes you haven’t written to disk yet but switched away from. For a session with hidden buffers, quitting will raise error messages, and vim will automatically display the first hidden buffer. You now have the following options: :w[rite] to write the buffer’s content to disk, :e[dit]! to reread the file from disk and thus revert all changes made, :qa[ll]! to discard all changes, and :wa[ll] to write all modified buffers to disk. :bufdo executes an Ex command in all open buffers, :argo in all grouped ones (e.g. :argdo %s/hello/world/g substitutes world for hello in all buffers in :args, :argdo edit! reverts all changes, and :argdo update writes changed buffers to disk. :[range]bd deletes buffers in range, with [range] working as for other Ex-commands (see above). Command Effect :x[it] / exi[t] Like :wq but only write if file was changed :xa Write all changed buffers and exit (like :wqa) vim-eunuch commands: Command Effect Move[!] {file} Like :saveas, but deletes old file Rename[!] {file} Rename current buffer and file Chmod {mode} Change permissions of current file Mkdir {dir} Create dir with mkdir() Mkdir! {dir} Create dir with mkdir() with “p” argument (mkdir -p) Toggle buffer settings from vim-unimpaired: Command Effect yoh Toggle search highlighting yob Toggle light background yoc Toggle cursor line highlighting yon Toggle line numbers yor Toggle relative line numbers yos Toggle the spell checker ","date":"2021-09-11","objectID":"/vim/:7:1","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Windows A window is a viewport onto a buffer. We can open different windows that all provide a (different) view onto the same buffer, or load multiple buffers into one window. Command Effect \u003cC-w\u003ew Go to next window \u003cC-w\u003es Split window horizontally \u003cC-w\u003ev Split window vertically :sp[lit] {file} Horizontally split window and load {file} into new buffer :vsp[lit] {file} Vertically split window and load {file} into new buffer :new Split horizontally with new file :vne[w] Split vertically with new file on[ly] Close all but current window \u003cC-w\u003e= Equalize width and height of all windows \u003cC-w\u003er Rorate windows \u003cC-w\u003ex Exchange position of current window with its neighbour q[uit] Close current window :sb[uffer] Open buffer number N in horizontal split :vert sb N Open buffer number N in vertical split (\u003cleader\u003evb) ","date":"2021-09-11","objectID":"/vim/:7:2","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Tabs A tab is a container of windows. Command Effect :tabe[dit]{file} Open new tab with {file} if specified or empty otherwise :[count]tabnew Open a new tab in an empty window. \u003cC-w\u003eT Move current window into new tab :tabc[lose] Close current tab with all its windows :tabo[nly] Close all tabs but the current one {N}gt Go to tab {N} if specified, or to next otherwise gT Go to previous tab Handy [count] options for tabnew: Count Opens new tab … [.] … after current one - … before current one 0 … before first one $ … after last one ","date":"2021-09-11","objectID":"/vim/:7:3","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Opening files I use command-t to fuzzy-find files, which is what I use most of the time when working inside a project. To navigate file trees, I use netrw and vinegar. Deleting folders: netrw uses delete() with the d flat to delete directories. As explained in :h delete(), this only removes empty directories. I leave this default for now. To easily open a new file from the same directory as the current buffer in a new window/split/vertical split/tab I use the mappings \u003cleader\u003eew/es/ev/et, following this Vimcast. command-t commands: Command Effect \u003cc-o\u003e Open or close command-t \u003cc-i\u003e Open command-t for open buffers \u003cc-f\u003e Flush path cash and rescan directory \u003cc-v\u003e Open file in vertical split netrw commands: Command Effect e[dit]. Open file explorer for current working directory E[xplore] Open file explorer for the directory of active buffer % Open new file in current directory d Create new directory in current one R Rename file or directory under cursor D Delete file or directory under cursor gh Toggle hiding dot-files :Ve Open explorer in vertical split :Rex Exit/return to explorer \u003cc-l\u003e Refresh listing ","date":"2021-09-11","objectID":"/vim/:7:4","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Navigation Motions move within a file, jumps between files. Each motion can be prepended by a count (5l moves five characters to the right). ","date":"2021-09-11","objectID":"/vim/:8:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Within files General: Command Effect \u003cC-g\u003e Shows current filepath and line number zz Redraw current line in middle of window zt Redraw current line at top of window Left-right and up-down: You can use search after an operator to great effect. For instance: typing d/to \u003cCR\u003e when the cursor is at the beginning of “after” in the previous sentence turns it into “You can use search to greate effect”. This works because d is an exclusive operator (h: exclusive) and doesn’t apply the operation on the endpoint of the selection. I use vim-smoothie for smoother screening behaviour of half-screen and screen-wise scrolling. Command Effect h/l Move left/right (use [count] as needed) j/k Down/up one line (think of j as a down arrow, use [count] as needed) gj/gk Down/up by display rather than real lines 0/^/$ To first non-blank/first/last character of line G Goto line [count], default is last line gg Goto line [count], default is first line f{char}/F{char} To next occurrence of {char} to the right/left t{char}/T{char} Till (before) next occurrence of {char} to the right/left H/M/L Jump to the top/middle/bottom of the screen \u003cC-e\u003e/\u003cC-y\u003e Scroll down/up linewise \u003cC-d\u003e/\u003cC-u\u003e Scroll down/up half-screen-wise (“down-up”) \u003cC-f\u003e/\u003cC-b\u003e Scroll down/up screen-wise (“forwards-backwards”) Words: Command Effect w/e Forward to start/end of current or next word b/ge Backward to start/end of current or previous word W, E, B Move WORD rather than word wise Text objects: Text objects come in two types: those within a pair of delimiters (e.g. text inside parentheses) and chucks of text (Vim calls them “block” and “non-block” objects). They can be moved over or selected. Text object selection start with i (“inner sentence”) or a (“a sentence”). For example: vi) highlights text inside parentheses but not the parentheses themselves, while va) highlights the parentheses as well. Useful tip: when I’m not inside a block object, nvim selects applies the command to the next one. Command Effect )/( Move [count] sentences forward/backward }/{ Move [count] paragraphs forward/backward Command Select inside or around… w/W word/WORD s sentence p paragraph ] a [] block ) or b a () block } or B a {} block \u003c a \u003c\u003e block t a tag block Marks: Command Effect m{a-zA-Z} Set lowercase (local) or uppercase (global) mark `{mark} Jump to mark double-backquote Go to position before last jump `. Go to position of last change % Go to matching bracket ","date":"2021-09-11","objectID":"/vim/:8:1","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Between files A jump is a long-range motion (which, roughly, means moving faster than WORD-wise). Traversing the jumps and changes lists Command Effect :jumps Show the jump list \u003cC-o\u003e/\u003cC-i\u003e Traverse jump history backwards/forwards :changes Show the change list g;/g, Traverse change list backwards/forwards gf Jump to file under cursor \u003cC-]\u003e Jump to definition of keyword under cursor ","date":"2021-09-11","objectID":"/vim/:8:2","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Back and forth Vim-unimpaired provides a set of normal mode commands to move between next (]) and previous ([), toggle options, and special pasting. Some commands I use often are listed below. The mnemonic is that ] is next in general and “next line” here, and lowercase navigates one by one while lowercase jumpts to first or last (e.g. [b moves to previous buffer, [B jumps to first one). Command Effect ]\u003cspace\u003e/[\u003cspace\u003e Add [count] blank lines below/above the cursor ]e/[e Exchanges the current line with the one below/above ","date":"2021-09-11","objectID":"/vim/:8:3","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Registers ","date":"2021-09-11","objectID":"/vim/:9:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Copy and paste A register is a container that holds text. By default, Vim deletes, yanks and puts to and from the unnamed register \". We can set the register with which a command interacts by prepending the command with \"{register}{cmd} (e.g. to explicitly state that we want to delete the current line to the unnamed register, we’d use \"\"dd; to put the just copied text, \"\"p. But these are equivalent to dd and p, so we’d probably not do that.) However, the default register will always contains the content from the last command, even if an additional register was specified. Transposing characters and lines: to correct “Thi sis”, starting from the last letter, use F\u003cspace\u003exp; to swap the current with the subsequent line, use ddp. As an alternative to ddp, which is useful to move lines up and down more flexibly, use ]e from vim-unimpaired (see below). Expression register: when we fetch the content of the expression register, Vim drops into command-line mode with a = prompt. When we enter Vim script and press \u003cCR\u003e, Vim will coerce the result into a string if possible and use it. Command Effect \"{reg}{cmd} Make {cmd} interact with register {reg} \"\" The unnamed register (redundant, as it’s the default) \"0 The yank register \"_ The black hole register (nothing returns from it) \"{a-z} Named registers (replace with {a-z}, append with {A-Z}) \"+ The system clipboard \"% Name of current file (e.g. \"%p) \"# Name of alternate file \". Last inserted text \": Last Ex command \"/ Last search pattern :reg[ister] [reg] List content of registers reg, all by default \u003cC-r\u003e{reg} Paste content of {reg} in insert mode Useful patterns: Replace firstword with secondword. Solution 1: cursor at beginning of secondword; ye; bb; ve; p. Solution 2: cursor at beginning of secondword; ye; bb; cw; \u003cC-r\u003e0. Has advantage that . now replaces current word with firstword. Swap firstword and secondword. Solution: cursor at beginning of firstword; de; mm; ww; ve; p; `m; P. Explanation: this exploits a quirk in the behaviour or p in visual mode. When we paste in visual mode, we put the content of the default register in place of the highlighted text, and the highlighted text into the default register. Complete the statement 27 * 45 = x. Solution: cursor at x and in insert mode; \u003cC-r\u003e=27*45\u003cCR\u003e. ","date":"2021-09-11","objectID":"/vim/:9:1","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Macros Macros can be executed in sequence (e.g. 22@a) or in parallel ([range]:normal @a). The former can be useful as it aborts on failure, which could be what we want (e.g. replace all search results and stop once none are left). But if it’s not, then the latter approach is more useful (e.g. if you want to perform a change on all list items but not on other lines). Command Effect q{a-z} Start recording macro to register q End recording [count]@{a-z} Invoke macro in register [count] times @@ Replay last invoked macro q{A-Z} Append to macro (e.g. if I forgot something) Exercises: In the below block of code, prepend *var * and append ; to each line. foo = 1 bar = 2 baz = 3 Edit macro q by prepending it with a ^ using a) yanking and b) visual editing (based on this useful post). Macro q hits its target with n; invoke it quickly for all 12 search results in the document. In the list below, change . to ) and words to title case. a. ho b. hi c. he Make the reverse changes in the list below a) Ho b) Hi // a comment c) He Turn the below lines into a numbered list. - first - second - third Turn the below list into a numbered list. - This is the first bullet - stretching over multiple lines. Well, actually, it didn't, but now it does. - The second bullet is long, too. Again, it wasn't really, but now it is, so we can actually simulate what would happen. - The third one is short. - The fourth and final one is long. Solutions: With the cursor anywhere on the first line, start recording and perform the change on the first line, then either repeat it (a) sequentially or (b) in parallel. qq, Ivar\u003cesc\u003eA;\u003cesc\u003ej, (a) 2@q, (b) Vj:normal@q. a) Paste the macro content into the buffer and edit it: \"qpI^\u003cesc\u003e, yank it back into the q register: \"qyy, clean macro from the buffer dd. b) Redefine the macro content directly using let command by opening the register :let @q=', pasting the current contents \u003cc-r\u003e\u003cc-r\u003eq, adding ^ at the beginning, and adding ' and press enter to close the quote and finish editing the macro. 22@q. Explanation: Because q uses n to hit its targets, it will automatically abort once there are no more results. We can thus avoid counting matches and simply use a number that’s comfortably above the number of matches. 22 is convenient because, on my keyboard, it’s the same key as @. Start with cursor anywhere on first line of list, record macro: qq0f.r)w~jq, replay macro: 22@q. Start with cursor anywhere on first line of list, record macro: qq0f.r)w~q, replay macro: V}:normal @q. Discussion: Executing the macro in series as in the previous exercise would abort at the line of the comment, so we need to execute it in parallel. As a result, there is no need to move to next line after performing the changes. Start anywhere on the first line, then instantiate the counter: :let i=1, record the changes: qq0s\u003cC-r\u003e=i\u003cCR\u003e)\u003cEsc\u003e, advance the counter: let i+=1, stop recording: q and replay: jVj:normal @q. My best solution thus far: We need a few preparation steps before we can execute the macro; first, select and then deselect the area within which you want to replace list item markers (e.g. vap, jk). Second, search for all list item markers inside that area using /\\%V\\_^-, where the \\%V atom restricts the search to the previous selection, the \\_^ atom matches start-of-line, and - matches the hyphens used as list item markers. Finally, initialise the counter using :let i=1. To record the marco, move the curser to before the first hypen in the list, then record the motions to the q register qq, move to the first hypehn and replace it while entering insert mode ncw, replace it with the counter and add a dot and exit insert mode \u003cc-r\u003e=i\u003ccr\u003e.jk, and increment the counter and stop the recording :let i=i+1q. Now, you can simply replay the recording in sequence 22@q and, if needed, reformat the area gvgq. (I use 22 to replay the macro for convenience as on my keyboard, 2 is the same key as the @ symbol, but any number at least as large as the number of","date":"2021-09-11","objectID":"/vim/:9:2","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Patterns ","date":"2021-09-11","objectID":"/vim/:10:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Matching patterns and literals In my .vimrc, I use set: ignorecase and set: smartcase to set the default search to be case insensitive except when I use an uppercase character in my pattern. You can use pattern swtiches anywhere in the search pattern. Use \\v for regex search, \\V for verbatim search. Command Effect \\c Force case insensitive search \\C Force case sensitive search \\v (very magic) All characters assume special meaning (regex-like search) \\V (very nomagic) No character but “\" has special meaning (verbatim search) () Capture matched pattern inside and store in numbered silo % When before (), don’t capture submatch \u003c/\u003e Word boundaries when used with \\v switch \\zs/\\ze Start and end of match Useful patterns: Find the but not words it is a part of (e.g. these). Solution: /\\v\u003cthe\u003e\u003cCR\u003e. In a CSS file, find all hex colour codes. Solution: /\\v#(\\x{6}|\\x{3}). Explanation: use \\v for regex search and \\x to capture hexadecimal characters (equivalent to [0-9a-fA-F]). Find “a.k.a.” in a file. Solution: /\\Va.k.a.. Explanation: we need \\V or else . matches any character and we’d also find words like “backwards”. Check for words that occurr twice in a row. Solution: /\\v\u003c(\\w+)\\_s+\\1\u003e. Explanation: (\\w+) captures any word, \\_s matches a linebreak or a space (see h: /\\_), \\1 is the reference to the previously captured word, and \u003c,\u003e ensure that only two occurrences of the same word get matched and not also patterns like “n” in “in nord”. Reverse the order of all occurrences of Fab Gunzinger and Fabian Gunzinger. Solution: /\\v(Fa%(b|bian)) (Gunzinger); :%s//\\2, \\1/g. Explanation: the first bit captures the short and full version of my first name, and my last name, without capturing the b or bian fragments. First and last name can now be references using \\1 and \\2, respectively. The substitution command finds the last search pattern (since we leave pattern blank) and replaces it with my first and last names reversed. Find all occurences of “Vim” that are part of “Practical Vim”. Solution: /Practical \\zsVim\u003cCR\u003e. Find all quoted text. Solution: /\\v\"\\zs[^\"]+\\ze\". Explanation: \"[^\"]+\" matches quotes followed by one or more occurances of anything but quotes followed by quotes (this is a useful regex idiom). \\zs and \\ze exclude the quotes from the match. Note: this only recognises quoted text on the same line. Note: doesn’t work over multiple lines. Find http://someurl.com/search?=\\//. Solution: Yank pattern into a register, u for url, say; /\\V\u003cC-r\u003e=escape(@u, getcmdtype().'\\')\u003cCR\u003e. Explanation: see tip 79 in PV. Exercises: In music amuse fuse refuse replace us with az in amuse and fuse using the substitute command (the point is to practice substitution in a limited area within a line). Solutions: Use to the a at the beginning of amuse, then use vee to select the two words needed, jk (my mapping for \u003cesc\u003e) to leave visual mode, and :s/\\%Vus/az/g to make the substitution in the last selected area: the \\%V atom is what restricts the substitution to the last selected area. ","date":"2021-09-11","objectID":"/vim/:10:1","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Search Within a file Command Effect /\u003cCR\u003e Search previous pattern forward ?\u003cCR\u003e Search previous pattern backwards /\u003cUP\u003e Access search history (similar for backward search) \u003cC-r\u003e\u003cC-w\u003e Autocomplete search field based on preview match /{pattern}/e\u003cCR\u003e Use search offset to jump to end of match (`h: search-offset` for more offset options) gn Operate on a complete search match Exercises: In the paragraph below, replace all occurrences of “lang” or “langs” with “language” or “languages”. learn a lang each year which lang did you learn? which lang will you learn? how many langs do you know? Now repeat the above, but start out by searching without using the search offset to jump to the end of the word and then make use of it midway through my search. Search for the line below each occurrence of “lang”. Replace all occurrences of “PyCode” and “PythonCode” with “PYCode” or “PYTHONCode”. Solutions: /lang/\u003cCR\u003e; ea; uage; n.. Explanation: the second / denotes teh end of the pattern, so from then on we’re back in command line mode. Use //e\u003cCR\u003e to repeat the previous search pattern but with search offset used. /lang/+1. Explanation: +# in search offset positions the cursor # lines after the match. /\\vPy(thon)?\\C\u003cCR\u003e; gUgn; .. Explanation: gn applies the pending operator (gU in this case) to the current match or, if the cursor isn’t on a match, on the next one. After executing gUgn for the first time, the cursor changes the first match and remains there. Once we press ., the word under the cursor no longer is a match, so Vim jumps to the next match and applies the pending gU operator. Drew Neil calls this the “Improved dot-formula”, since we can use . to achieve n.. Across files There are many options for this. I currently use vim-ripgrep. The basic syntax is :Rg \u003cstring|pattern\u003e, with \u003cstring|pattern\u003e defaulting to the word under the cursor. Vim will ist the results in the quickfix window and jump to the first entry in the window. Exercises: Find all files that contain the line import s3fs in (a) the current directory and (b) in the subdirectory /data. Solutions: (a) :Rg 'import s3fs, (b) :Rg 'import s3fs' data/. ","date":"2021-09-11","objectID":"/vim/:10:2","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Substitution Full syntax is :[range]s[ubstitute]/{pattern}/{string}/[flags] For substitutions across files I use quickfix-reflector, which allows for editing the quickfix window, and performs the changes made there in all files. Flags: Command Effect g Substitute all matches on line (global) c Confirm substitution n Count number of matches instead of substitution \u0026 Reuse flags from previous substitution Replacement strings: Command Effect \\1 Insert first submatch (similar for {1-9}) \\0/\u0026 Insert entire matched pattern ~ Use string from previous substitution \\={vim scrip} Evaluate vim-script expression Useful commands Command Effect :\u0026 Rerun last substitution (flags aren’t remembered) :\u0026\u0026 Rerun last substitution and reuse flags :g\u0026 Rerun last search globally Exercise: Replace import helpers.aws as ha with from helpers import aws in all files in the current directory. Decouple pattern matching and substitution (useful for complex patterns that require trial and error). Use last search pattern in substitute command. Substitute the highlighted text fragment. Rerun the last line-wise substitution globally. In a file with columns “name”, “age”, “height”, change order to “height”, “name”, “age”. Replace “Hello” in (and only in) “Hello World” with “Hi” in all files in my project. Solutions: Find all files and open the quickfix window :Rg 'import helpers.aws as ha', perform the change in each file inside the quickfix window and save. /{pattern} until you get it right (maybe use q/), then :s//{string}. Explanation: leaving {pattern} blank uses last search pattern. :s/\u003cC-r\u003e//{string} *:s//{string}. Explanation: with vim visual star plugin installed, * searches for pattern highlighted in visual mode. g\u0026. /\\v^([^,]), ([^,]), ([^,])$; :%s//\\3, \\1, \\2. First, test pattern in current buffer: /Hello\\ze World\u003cCR\u003e, then search all files in project and populate quickfix list with files that have a match: :vimgrep // **/*.txt, finally: iterate through the files in the quickfix list to execute the substitute and update commands: :cfdo %s//Hi/gc | update ","date":"2021-09-11","objectID":"/vim/:10:3","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Global commands` Full syntax: :[range] global[!] /{pattern}/ {cmd}. Range defaults to the entire file, leaving the pattern empty uses last search pattern, and command defaults to print. A generalised version of the command, useful to operate inside text or code blocks, is :g/{start} .,{finish} [cmd], which applies the command to each range of lines that begins with {start} and ends with {finish}. See CSS sorting example below. Command Effect g[lobal] Global command v[global] Invert global g[lobal]! Invert global Exercises: Delete all lines that contain “Hi”. Keep only lines that contain “Hi”. Print all lines that contain “Hi”. Yank all lines that contain “TODO” into register a. Glance at markdown file structure (create a table of contents). Glance at top-level markdown titles. Glance at markdown top and secondary level titles. Alphabetically sort properties inside each rule of a CSS file. Solutions: :g/Hi/d. :v/Hi/d. :g/Hi. qaq (to empty register); :g/TODO/yank A. Explanation: need capital A to append to rather than overwrite register. g/^#. :g/^# :g/\\v^#(#)? . Explanation: Need \\v so that parentheses have magic characteristics (otherwise I’d have to escape them, which is cumbersome), need ? … :g/{/ .+1,/}/-1 sort. Explanation: /{/ is the pattern of the global command and searches for all lines that contain an {. .+1,/}/-1 is the range of the Ex command, specified as from the current line until the next line that contains a closing curly bracket. The offsets narrow the range to exclude the lines with curly brackets. The current line address here stands for each line in turn that matches the /{/ pattern. ","date":"2021-09-11","objectID":"/vim/:10:4","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Folds Command Effect zR Open all folds zM Close all folds \u003cleader\u003e\u003cspace\u003e Toggle fold under cursor (mapping of za) ","date":"2021-09-11","objectID":"/vim/:11:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Mappings General syntax: {cmd} {attr} {lhs} {rhs}. Mapping process: define the sequence of keys to be mapped, decide the editing mode in which the mapping will work, find a suitable and free key sequence. Understanding noremap mappings: by default, vim mappings are recursive (i.e. if a is mapped to b and b to c, then a is really mapped to c because b will be expanded on the rhs. The second mapping could be part of a plugin so that I’m not even aware of it). This behaviour is set with the remap option. To define non-recursive mappings, we can use the noremap mappings. Command Effect :nmap {char} List all normal mode mappings starting with {char} :verbose nmap {char} As above, but shows location where maps are defined ","date":"2021-09-11","objectID":"/vim/:12:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Editing ","date":"2021-09-11","objectID":"/vim/:13:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Autocompletion Command Effect \u003cC-n\u003e/\u003cC-p\u003e Trigger autocompletion and navigate \u003cC-e\u003e Dismiss autocomplete window \u003cC-n\u003e\u003cC-p\u003e Filter suggestions as we type \u003cC-x\u003e\u003cC-k\u003e Dictionary lookup (requires spellchecker on - yos) \u003cC-x\u003e\u003cC-l\u003e Autocomplete entire line \u003cC-x\u003e\u003cC-f\u003e Autocomplete filename (relative to pwd) I’ve experimented with youcompleteme, which I deleted again because its too clunky for my taste. In case I want to install again in the future, this might be helpful: Often doesn’t work with Anaconda Python, and I seem to be one of those cases. Followed the suggestion in the link. I first tried compiling with /usr/bin/python3, but this didn’t work. I then tried /usr/local/bin/python3.9, following this, which seems to have worked. ### Spell checking Command Effect yos Toggle spell checker (uses vim-unimpaired) ]s/[s Jump to next/previous misspelled word z= Suggest corrections [n]z= Correct word with nth suggestion zg Add current word to spell file (mnem: “good”) zw Remove current word from spell file (mnem: “wrong”) zug Revert zg or zw command for current word ### Formatting Command Effect gq{motion} Formats text, defaults to wrapping long lines. ### Case coercion Uses vim-abolish, which deals with word variants and provides powerful searching, grepping, substitution and case coercion. Command Effect crs Coerce to snake_case crc Coerce to camelCase crm Coerce to MixedCase cru Coerce to UPPER_CASE cr- Coerce to dash-case cr. Coerce to dot.case cr\u003cspace\u003e Coerce to space case crt Coerce to Title Case Exercises: Replace all occurrences of child[ren] with adult[s]. Replace all occurrences of man with dog and vice versa. Solutions: :%S/child{,ren}/adult{,s}/g :%S/{man,dog}/{dog,man}/g. Discussion: Don’t use whitespace after comma, as Vim would treat it as part of the search/replacement pattern. ","date":"2021-09-11","objectID":"/vim/:13:1","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Comments Uses vim-commentary Main commands: gc{motion} gcc {Visual}gc :[range]Commentary ","date":"2021-09-11","objectID":"/vim/:13:2","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Language and program specific settings ","date":"2021-09-11","objectID":"/vim/:14:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Git I use basic commands from vim-fugitive ","date":"2021-09-11","objectID":"/vim/:14:1","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Python Execute makefiles using :make (Set up quicklist such that I can jump to errors directly, this currently doesn’t work. Probably requires some additional setup to recognise Python errors.) I use Ctags to navigate my codebase. I’ve followed Tim Pope’s approach to set this up. For newly initialised or cloned directories, this setup automatically creates hooks and indexes the code with Ctags. For existing directories, you need to run git init to copy the hook templates into the local .git/hooks, and then git ctags to index the code. Ctag commands: Command Effect \u003cC-]\u003e Jump to definition of keyword under cursor g\u003cC-]\u003e As above, but select definition if there are multiple :tag {keyword} Jump to definition of keyword :tjump {keyword} As above, but select definition if there are multiple Look into using matchit or something similar for faster code navigation. ","date":"2021-09-11","objectID":"/vim/:14:2","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Latex You can use \u003cC-N\u003e completion for words that already appear in one of the open buffers. This is especially useful for bibliography completion: just open the .bib file in another buffer and \u003cC-N\u003e will provide a list of available keys. I use vimtex, with Skim as my viewer. In vimtex, most shortcuts use localleader, which, by default, is set to \\. Vimtex commands: Command Effect \\ll Toggle continuous compilation using latexmk \\lk Kill compilation process \\lc Clear auxiliary files \\lt Show table of contents \\ds{c/e/$/d} Delete surrounding command/environment/math env/delimiter \\cs{c/e/$/d} Change surrounding command/environment/math env/delimiter :VimtexDocPackage Show docs for argument under cursor or supplied package :VimtexCountWords Count words in document \u003cC-x\u003e\u003cC-o\u003e/ Citation completion (inside \\cite{) ]] To next section ]m To next environment ]n To next math zone ]r To next frame Vimtex text objects: Command Effect c Command d Delimiters (e.g. [, {) e Environment $ Inline math environment P Sections m Items ","date":"2021-09-11","objectID":"/vim/:14:3","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Obscurities \u003cplug\u003e Allows authors of plugins to pre-map commands to so users can easily map them to their preferred keys. E.g. \u003cplug\u003e(test) might stand for a very long sequence of commands. To map that sequence to \u003cleader\u003et, I can simply use nmap \u003cleader\u003et \u003cplug\u003e(test). This SE answer explains it very clearly. ","date":"2021-09-11","objectID":"/vim/:15:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Troubleshooting ","date":"2021-09-11","objectID":"/vim/:16:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Command-t ruby version differs from expected Error mesassage: “command-t cound not load the C extension … VIM RUBY version (version number) Expected version (different version number).” Solution: recompile Command-T with the new system Ruby. Steps are detailed under “Compiling Command-T” in the Command-T helpfiles. They are as follows: cd~/.config/nvin/plugged/command-t/ruby/command-t/ext/command-t ruby extconf.rb make. ","date":"2021-09-11","objectID":"/vim/:16:1","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"CSS indent not working Vim recognised css files, but used my global indent of 4 spaces rather than a file-type specific indent of 2 spaces. h: filetype notes that filetype detection files are located in the runtime path. Going there, I found the ftplugins folder that contains the default file settings. Looking at css.vim makes clear that it doesn’t set any tabstop settings, which explains why the defaults were used. Googling something along the lines of “custom filetype indent vim” let me to this SO answer, which helpfully links to h: filetype-plugins. Once there, it was easy to find the relevant section, ftplugin-overrule that documents how to add custom filetype settings. This is what I did, and it worked like a charm. ","date":"2021-09-11","objectID":"/vim/:16:2","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":["craft"],"content":"Sources This cheat sheet started out as a summary of Drew Neil’s phenomenal Practical Vim, which I can’t recommend enough as a start to learning Vim seriously. Other resources I found useful: Vim Fandom mappings tutorial Dough Black’s good vimrc Using help: https://vim.fandom.com/wiki/Learn_to_use_help Idiomatic VIM Awesome vimrc: https://github.com/amix/vimrc Vim as Python IDE: https://realpython.com/vim-and-python-a-match-made-in-heaven/ ","date":"2021-09-11","objectID":"/vim/:17:0","tags":["tools","cheatsheet"],"title":"Vim cheatsheet","uri":"/vim/"},{"categories":null,"content":"Raw strings Raw string notation keeps regular expressions sane. re tutorial ","date":"2021-03-23","objectID":"/python-regex/:1:0","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Raw strings in Python Just like the regex engine, Python uses \\ to escape characters in strings that otherwise have special meaning (e.g. ' and \\ itself) and to create tokens with special meaning (e.g. \\n). print(\"Hello\\nWorld\") Hello World Without escaping a single quotation mark, it takes on its special meaning as a delimiter of a string. 'It's raining' SyntaxError: invalid syntax (3769801028.py, line 1) To give it its literal meaning as an apostrophe, we need to escape it. \"It's raining\" \"It's raining\" ","date":"2021-03-23","objectID":"/python-regex/:1:1","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Python and regex interaction A string is processed by the Python interpreter before being passed on to the regex engine. Once consequence of this is that if in our regex pattern we want to treat as a literal a character that has special meaning in both Python and regex, we have to escape it twice. For example: to search for a literal backslash in our regex pattern, we need to write \\\\\\\\. The Python interpreter reads this as \\\\ and passes it to the regex engine, which then reads it as \\ as desired. import re s = \"a \\ b\" m = re.search(\"a \\\\\\\\ b\", s) print(m[0]) m[0] a \\ b 'a \\\\ b' This is obviously cumbersome. A useful alternative is to use raw strings r'', which make the Python interpreter read special characters as literals, obviating the first set of escapes. Hence, it’s a good idea to use raw strings in Python regex expressions. m = re.search(r\"a \\\\ b\", s) print(m.group()) a \\ b ","date":"2021-03-23","objectID":"/python-regex/:1:2","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Escape sequences rabbit hole First things first: an escape sequence is a a sequence of characters that does not represent itself when used within a string literal but is translated into another character or sequence of characters that might be difficult or impossible to represent (from Wikipedia). When I tried a version of this string = \"foo 1a bar 2baz\" pattern = \"\\b\\d[a-z]\\b\" re.findall(pattern, string) [] it took me 10 minutes to figure out why 1a didn’t match. The short answer is: thou shalt use raw strings! raw_pattern = r\"\\b\\d[a-z]\\b\" re.findall(raw_pattern, string) ['1a'] But why? Because Python interpretes escape sequences in strings according to the rules of Standard C, where \\b happens to stand for the backspace. Hence, the pattern without the r prefix means “a backspace immediately followed by a digit immediately followed by a lowercase letter immediately followed by another backspace”, which is not present in the string. To convince ourselves of this, we can add backspaces to the string and try again – now the pattern matches. string = \"foo \\N{backspace}1a\\N{backspace} baz 2bar\" re.findall(pattern, string) ['\\x081a\\x08'] One point that was not immediately obvious to me was why pattern works without the backspace character – why do the backspaces in \\d and \\w not need escaping? pattern = \"\\d\\w\" re.findall(pattern, string) ['1a', '2b'] The explanation is that \\ is interpreted literally if it is not part of an escape sequence, as in print(\"a\\k\") a\\k and \\d and \\w aren’t escape sequences in Python (or C). Hence, these two tokens are passed on unaltered to the regex engine, where they are interpreted according to regex syntax rules. ","date":"2021-03-23","objectID":"/python-regex/:1:3","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Remove punctuation rabbit hole I wanted to remove punctuation in a string like the below. s = \"Some .' test \u0026 with * punctuation \\ characters.\" Thinking I was clever, I thought of the useful constants provided by the string module, which provide easy access to character sequences like the set of punctuation characters. import string string.punctuation '!\"#$%\u0026\\'()*+,-./:;\u003c=\u003e?@[\\\\]^_`{|}~' I did the below and was about to celebrate victory. p = string.punctuation try: re.sub(p, \" \", s) except Exception as e: print(e) multiple repeat at position 10 Oops! It’s a clear case where I jupmpted to a conclusion a little bit too soon, and where spending a few more minutes thinking things through before starting to code would probably have helped me see the two flaws in my approach: I need to escape special characters, and, given that I want to search for characters individually, I need to wrap them in a character rather than passing them as a single string🤦‍♂️ p = f\"[{re.escape(string.punctuation)}]\" r = re.sub(p, \"\", s) r 'Some test with punctuation characters' To remove extra whitespace, I could use: re.sub(\" +\", \" \", r) 'Some test with punctuation characters' Alternatively, I could use a regex-native approach. p = r\"[\\W_]\" re.sub(p, \" \", s) 'Some test with punctuation characters ' ","date":"2021-03-23","objectID":"/python-regex/:1:4","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"re module import re Overview of search methods pattern = \"a\" string = \"Jack is a boy\" methods = [ (\"re.match (start of string)\", re.match(pattern, string)), (\"re.search (anywhere in string)\", re.search(pattern, string)), (\"re.findall (all matches)\", re.findall(pattern, string)), (\"re.finditer (all matches as iterator)\", re.finditer(pattern, string)), ] for desc, result in methods: print(\"{:40} -\u003e {}\".format(desc, result)) re.match (start of string) -\u003e None re.search (anywhere in string) -\u003e \u003cre.Match object; span=(1, 2), match='a'\u003e re.findall (all matches) -\u003e ['a', 'a'] re.finditer (all matches as iterator) -\u003e \u003ccallable_iterator object at 0x11236d2e0\u003e ","date":"2021-03-23","objectID":"/python-regex/:2:0","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"re.findall() Returns list of all matches if no capturing groups specified, and a list of capturing groups otherwise. Example: find stand-alone numbers data = \"\"\" 012 foo34 56 78bar 9 a10b \"\"\" Without capturing groups entire match is returned proper_digits = \"\\s+\\d+\\s+\" re.findall(proper_digits, data, flags=re.MULTILINE) ['\\n 012\\n', ' \\n 56\\n', '\\n9\\n '] One capturing groups returns list of capturing groups proper_digits = \"(?m)\\s+(\\d+)\\s+\" re.findall(proper_digits, data, flags=re.MULTILINE) ['012', '56', '9'] Multiple capturing groups return list of multi-tuple capturing groups proper_digits = \"\\s+(\\d)(\\d+)?\\s+\" re.findall(proper_digits, data, flags=re.MULTILINE) [('0', '12'), ('5', '6'), ('9', '')] To return the full match if the pattern uses capturing groups, simply capture the entire match, too. s = \"Hot is hot. Cold is cold.\" p = r\"((?i)(\\w+) is \\2)\" [groups[0] for groups in regex.findall(p, s)] ['Hot is hot', 'Cold is cold'] Finding overlapping matches pattern = r\"(?=(\\w+))\" re.findall(pattern, \"abc\") ['abc', 'bc', 'c'] ","date":"2021-03-23","objectID":"/python-regex/:2:1","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"re.match() Find pattern at the beginning of a string line = '\"688293\"|\"777\"|\"2011-07-20\"|\"1969\"|\"20K to 30K\"' pattern = r'\"\\d+\"\\|\"(?P\u003cuser_id\u003e\\d+)\"' match = re.match(pattern, line) print(match) print(match.group(\"user_id\")) print(match[\"user_id\"]) # alternative, simpler, syntax \u003cre.Match object; span=(0, 14), match='\"688293\"|\"777\"'\u003e 777 777 from itertools import compress addresses = [ \"5412 N CLARK\", \"5148 N CLARK\", \"5800 E 58TH\", \"2122 N CLARK\" \"5645 N RAVENSWOOD\", \"1060 W ADDISON\", \"4801 N BROADWAY\", \"1039 W GRANVILLE\", ] def large_house_number(address, threshold=2000): house_number = int(re.match(\"\\d+\", address)[0]) return house_number \u003e threshold has_large_number = [large_house_number(x) for x in addresses] list(compress(addresses, has_large_number)) ['5412 N CLARK', '5148 N CLARK', '5800 E 58TH', '2122 N CLARK5645 N RAVENSWOOD', '4801 N BROADWAY'] ","date":"2021-03-23","objectID":"/python-regex/:2:2","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"re.escape() I want to match “(other)”. To match the parentheses literally, I’d have to escape them. If I don’t, the regex engine interpres them as a capturing group. m = re.search(\"(other)\", \"some (other) word\") print(m) m[0] \u003cre.Match object; span=(6, 11), match='other'\u003e 'other' I can escape manually. re.search(\"\\(other\\)\", \"some (other) word\") \u003cre.Match object; span=(5, 12), match='(other)'\u003e But if I have many fields with metacharacters (e.g. variable values that contain parentheses) this is a massive pain. The solution is to just use re.escape(), which does all the work for me. re.search(re.escape(\"(other)\"), \"some (other) word\") \u003cre.Match object; span=(5, 12), match='(other)'\u003e ","date":"2021-03-23","objectID":"/python-regex/:2:3","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"re.split() pattern = r\"(?\u003c=\\w)(?=[A-Z])\" s = \"ItIsAWonderfulWorld\" re.split(pattern, s) ['It', 'Is', 'A', 'Wonderful', 'World'] ","date":"2021-03-23","objectID":"/python-regex/:2:4","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"re.sub() Stip a string of whitespace and punctuation. s = \"String. With! Punctu@tion# and _whitespace\" re.sub(r\"[\\W_]\", \"\", s) 'StringWithPunctutionandwhitespace' Using zero-width match to turn CamelCase into snake_case s = \"ThisIsABeautifulDay\" pattern = r\"(?\u003c=[a-zA-Z])(?=[A-Z])\" re.sub(pattern, \"_\", s).lower() 'this_is_a_beautiful_day' Use same approach with MULTILINE mode to comment out all lines. s = \"\"\"first second third\"\"\" pattern = \"(?m)^\" print(re.sub(pattern, \"#\", s)) #first #second #third ","date":"2021-03-23","objectID":"/python-regex/:2:5","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Matching end of line and end of string \\Z matches strict end of string but not cases where last character is a line-break a = \"\"\"no newline at end\"\"\" b = \"\"\"newline at end \"\"\" print(re.search(r\"d\\Z\", a)) print(re.search(r\"d\\Z\", b)) \u003cre.Match object; span=(17, 18), match='d'\u003e None \\$ matches end of string flexibly (i.e. before or after final linebreak) a = \"\"\"no newline at end\"\"\" b = \"\"\"newline at end \"\"\" print(re.findall(r\"[ed]$\", a)) print(re.findall(r\"[ed]$\", b)) ['d'] ['d'] \\$ with MULTILINE mode matches end of line a = \"\"\"no newline at end\"\"\" b = \"\"\"newline at end \"\"\" print(re.findall(r\"(?m)[ed]$\", a)) print(re.findall(r\"(?m)[ed]$\", b)) ['e', 'd'] ['e', 'd'] ","date":"2021-03-23","objectID":"/python-regex/:2:6","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"regex module docs Todo: Comparison between re and regex. # would usually import as `import regex as re`, but because I # want to compare to built-in re here, I'll import as regex. # default version is VERSION0, which emulates re to use additional # functionality, use VERSION1 import regex regex.DEFAULT_VERSION = regex.VERSION1 ","date":"2021-03-23","objectID":"/python-regex/:3:0","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Keep out token The keep out token \\K drops everything matched thus far from the overall match to be returned. pattern = r\"\\w+_\\K\\d+\" string = \"abc_12\" regex.match(pattern, string)[0] '12' ","date":"2021-03-23","objectID":"/python-regex/:3:1","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Inline flags Flags placed inside the regex pattern take effect from that point onwards. As an example, this helps us find uppercase words that later appear in lowercase. To start, let’s match all words that reappear later in the string. string = \"HELLO world hello world\" pattern = r\"(?i)(\\b\\w+\\b)(?=.*\\1)\" re.findall(pattern, string) ['HELLO', 'world'] To only match uppercase words that later reappear in lowercase, we can do this (explanation): pattern = r\"(\\b[A-Z]+\\b)(?=.*(?=\\b[a-z]+\\b)(?i)\\1)\" regex.findall(pattern, string) ['HELLO'] ","date":"2021-03-23","objectID":"/python-regex/:3:2","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Subroutines Subroutines obviate the repetition of long capturing groups s = \"Tarzan loves Jane\" p = r\"(Tarzan|Jane) loves (?1)\" m = regex.search(p, s) m[0], m[1] ('Tarzan loves Jane', 'Tarzan') Recursive patterns Subroutines can call themselves to create a recursive pattern, which can be useful to match tokens where one letter is perfectly balanced by another. s = \"ab and aabb and aab and aaabbb and abb\" p = r\"\\b(a(?1)?b)\\b\" regex.findall(p, s) ['ab', 'aabb', 'aaabbb'] Experimental only standalone expressions s = \"aaaabbbb aabb aab ab\" p = r\"a(?R)?b\" regex.findall(p, s) ['aaaabbbb', 'aabb', 'ab', 'ab'] s = \"a a a a b b b b aabb aab ab\" p = r\"\\b ?a(?R)? b\\b\" regex.findall(p, s) ['a a a a b b b b'] Pre-defined subroutines We can predefine subroutines to produce nicely modular patterns that can easily be reused through our regex. (The \\ in the pattern is needed because in free-spacing mode, whitespace that we want to match rather than ignore needs to be escaped.) defs = \"\"\" (?(DEFINE) (?\u003cquant\u003e\\d+) (?\u003citem\u003e\\w+) ) \"\"\" pattern = rf\"{defs} (?\u0026quant)\\ (?\u0026item)\" string = \"There were 5 elephants walking towards the water hole.\" regex.search(pattern, string, flags=regex.VERBOSE) \u003cregex.Match object; span=(11, 22), match='5 elephants'\u003e A useful application of this is to create real-word boundaries (rwb) that match between letters and other characters (rather than between word and non-word characters). defs = \"\"\" (?(DEFINE) (?\u003crwb\u003e (?i) # case insensitive (?\u003c![a-z])(?=[a-z]) # beginning of word |(?\u003c=[a-z])(?![a-z]) # end of word ) ) \"\"\" pattern = rf\"{defs} (?\u0026rwb)\\w+(?\u0026rwb)\" string = \"\"\" cats23, +dogs55, %bat*\"\"\" regex.findall(pattern, string, flags=regex.VERBOSE) ['cats', 'dogs', 'bat'] Using default word boundaries in the above string would also return digits and underscores, since they are word characters. regex.findall(r\"\\b\\w+\\b\", string) ['cats23', 'dogs55', 'bat'] ","date":"2021-03-23","objectID":"/python-regex/:3:3","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Named groups Supports named groups with a cleaner syntax: (?\u003cname\u003e...) instead of the somewhat verbose (?P\u003cname\u003e...) to define named groups s = \"Zwätschgi was born on 23 Dec 1986\" p = r\"\\b(?\u003cday\u003e\\d{2}) (?\u003cmonth\u003e\\w{3}) (?\u003cyear\u003e\\d{4})\\b\" regex.search(p, s).groupdict() {'day': '23', 'month': 'Dec', 'year': '1986'} and \\g\u003cname\u003e instead of (?P=name) for backreference. s = \"2012-12-12\" p = \"\\d\\d(?\u003cyy\u003e\\d\\d)-\\g\u003cyy\u003e-\\g\u003cyy\u003e\" regex.match(p, s) \u003cregex.Match object; span=(0, 10), match='2012-12-12'\u003e ","date":"2021-03-23","objectID":"/python-regex/:3:4","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Unicode categories regex provides support for unicode categories, which can be super handy. ## search for any punctuation character s = \". and _\" pattern = r\"\\p{P}\" regex.findall(pattern, s) ['.', '_'] ","date":"2021-03-23","objectID":"/python-regex/:3:5","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Variable-width lookbehinds One useful feature of regex is that it allows for variable-width lookbehinds. Like most regex engines, the re doesn’t and tells you so if you try. For example, if we want to match uppercase words preceeded by a prefix compused of digits and an underscore, such as BANANA in 123_BANANA, the below doesn’t work: string = \"123456_ORANGE abc12_APPLE\" pattern = r\"(?\u003c=\\b\\d+_)[A-Z]+\\b\" try: re.findall(pattern, string) except Exception as e: print(e) look-behind requires fixed-width pattern In contrast, regex succeeds. regex.findall(pattern, string) ['ORANGE'] Another application is if we wanted (for whatever reason) to match all words beginning with a at the beginning of a line from lines three onwards. string = \"\"\"abba abacus alibaba ada beta adagio aladin abracadabra \"\"\" pattern = \"(?\u003c=\\n.*\\n)a\\w+\" regex.findall(pattern, string) ['alibaba', 'aladin'] ","date":"2021-03-23","objectID":"/python-regex/:3:6","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Character class set operations Intersection # inside [] are optional but can make pattern easier to read pattern = r\"[[\\W]\u0026\u0026[\\S]]\" subject = \"a.b*5_c 8!\" regex.findall(pattern, subject) ['.', '*', '!'] Union pattern = r\"[ab||\\d]\" subject = \"a.b*5_c 8!\" regex.findall(pattern, subject) ['a', 'b', '5', '8'] Subtraction pattern = r\"[[a-z]--[b]]\" subject = \"a.b*5_c 8!\" regex.findall(pattern, subject) ['a', 'c'] pattern = \"[\\w--[_\\d]]\" subject = \"a b 3 k _ f 4\" regex.findall(pattern, subject) ['a', 'b', 'k', 'f'] ","date":"2021-03-23","objectID":"/python-regex/:3:7","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Pandas import pandas as pd ","date":"2021-03-23","objectID":"/python-regex/:4:0","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Insert text in position Insert an underscore between words df = pd.DataFrame({\"a\": [\"HelloWorld\", \"HappyDay\", \"SunnyHill\"]}) pattern = r\"(?\u003c=[a-z])(?=[A-Z])\" df[\"a\"] = df.a.str.replace(pattern, \"_\", regex=True) df a 0 Hello_World 1 Happy_Day 2 Sunny_Hill def colname_cleaner(df): \"\"\"Convert column names to stripped lowercase with underscores.\"\"\" df.columns = df.columns.str.lower().str.strip() return df def str_cleaner(df): \"\"\"Convert string values to stripped lowercase.\"\"\" str_cols = df.select_dtypes(\"object\") for col in str_cols: df[col] = df[col].str.lower().str.strip() return df movies = data.movies().pipe(colname_cleaner).pipe(str_cleaner) movies.head(2) title us gross worldwide gross us dvd sales production budget release date mpaa rating running time min distributor source major genre creative type director rotten tomatoes rating imdb rating imdb votes 0 the land girls 146083.0 146083.0 NaN 8000000.0 jun 12 1998 r NaN gramercy None None None None NaN 6.1 1071.0 1 first love, last rites 10876.0 10876.0 NaN 300000.0 aug 07 1998 r NaN strand None drama None None NaN 6.9 207.0 ","date":"2021-03-23","objectID":"/python-regex/:4:1","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Finding a single pattern in text pattern = \"hello\" text = \"hello world it is a beautiful day.\" match = re.search(pattern, text) match.start(), match.end(), match.group() (0, 5, 'hello') In Pandas movies.title.str.extract(\"(love)\") 0 0 NaN 1 love 2 NaN 3 NaN 4 NaN ... ... 3196 NaN 3197 NaN 3198 NaN 3199 NaN 3200 NaN 3201 rows × 1 columns contains(): Test if pattern or regex is contained within a string of a Series or Index. match(): Determine if each string starts with a match of a regular expression. fullmatch(): extract(): Extract capture groups in the regex pat as columns in a DataFrame. extractall(): Returns all matches (not just the first match). find(): findall(): replace(): movies.title.replace(\"girls\", \"hello\") 0 the land girls 1 first love, last rites 2 i married a strange person 3 let's talk about sex 4 slam ... 3196 zack and miri make a porno 3197 zodiac 3198 zoom 3199 the legend of zorro 3200 the mask of zorro Name: title, Length: 3201, dtype: object Let’s drop all movies by distributors with “Pictures” and “Universal” in their title. # inverted masking names = [\"Universal\", \"Pictures\"] pattern = \"|\".join(names) mask = movies.distributor.str.contains(pattern, na=True) result = movies[~mask] result.head(2) title us_gross worldwide_gross us_dvd_sales production_budget release_date mpaa_rating running_time_min distributor source major_genre creative_type director rotten_tomatoes_rating imdb_rating imdb_votes 0 The Land Girls 146083.0 146083.0 NaN 8000000.0 Jun 12 1998 R NaN Gramercy None None None None NaN 6.1 1071.0 1 First Love, Last Rites 10876.0 10876.0 NaN 300000.0 Aug 07 1998 R NaN Strand None Drama None None NaN 6.9 207.0 # negated regex names = [\"Universal\", \"Pictures\"] pattern = \"\\|\".join(names) neg_pattern = f\"[^{pattern}]\" neg_pattern mask = movies.distributor.str.contains(neg_pattern, na=False) result2 = movies[mask] neg_pattern '[^Universal\\\\|Pictures]' def drop_card_repayments(df): \"\"\"Drop card repayment transactions from current accounts.\"\"\" tags = [\"credit card repayment\", \"credit card payment\", \"credit card\"] pattern = \"|\".join(tags) mask = df.auto_tag.str.contains(pattern) \u0026 df.account_type.eq(\"current\") return df[~mask] ","date":"2021-03-23","objectID":"/python-regex/:4:2","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":null,"content":"Sources Python string documentation Pyformat Fluent Python Python Cookbook Learning Python Python for Data Analysis Python Data Science Handbook ","date":"2021-03-23","objectID":"/python-regex/:5:0","tags":["python"],"title":"Regex in Python","uri":"/python-regex/"},{"categories":["craft"],"content":"This is my cheetsheet for all things Unix. I use it to keep track of useful things I learn and want to remember. ","date":"2020-11-12","objectID":"/unix-basics/:0:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Basics A process is a running instance of a program. Everything is a fiele (the keyboard is read-only, the screen write only) man \u003ccommand\u003e opens the manual for \u003ccommand\u003e. man -k \u003csearch term\u003e lists all commands with \u003csearch term\u003e in the manual pages. ","date":"2020-11-12","objectID":"/unix-basics/:1:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Stuff I use often and tend to forget Creating a soft link: ln -s \u003cfile\u003e \u003clink\u003e. If you use . for \u003clink\u003e, a link with the same name as \u003cfile\u003e will be created in the current location. Renaming multiple files: rename 's/\u003cpattern to replace\u003e/\u003cnew pattern\u003e' [files]. For example, to replace foo with bar in all Python files, use rename 's/foo/bar/' *.py. Notice that the string command passed is a vim substitution pattern. Copying and pasting from and to the clipboard: pbcopy and pbpaste allow you to copy from and paste to the terminal. I often use pwd | pbcopy to get a directory path for use elsewhere, and pbpaste \u003e .gitignore to create a gitignore file from a template (e.g. from gitignore.io). Using the test utility: Use [[ condition ]] instead of [ condition ]. They are both test utilities, but the former is an extension of the latter that’s supported in all shells I’d ever use (see here). Moving current process to background: use ctrl-z to move current job to background, jobs to list running background jobs, and fg \u003cjob id\u003e to move job to foreground. ","date":"2020-11-12","objectID":"/unix-basics/:2:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Bash scripting ' and \": single quotes are used to interpret all content literally, while double quotes allow for variable substitution. For example, echo '$PATH' will print $PATH, while echo \"$PATH\" will print the value of $PATH. $( command ): saves command output into a variable. For example, myvar=$(ls) will save the output of ls into myvar. export var: makes var available to child process. For example, export PATH=$PATH:/usr/local/bin will add /usr/local/bin to the PATH variable. let var=expr: assigns result of expression to a variable. For example, let var=5+5 will assign 10 to var. expr: prints result of expression. For example, expr 5 + 5 will print 10. $(( expression )): returns the result of expression. For example, echo $(( 5 + 5 )) will print 10. Create a basic function in bash: function_name () { \u003ccommands\u003e } ","date":"2020-11-12","objectID":"/unix-basics/:3:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Permissions Three actions: r (read), w (write), x (execute). Three types of users: owner or user (u), group (g), and others (o). (a) applies to all types. Permission info is 10 characters long: first character is file type (- for file, d for directory), the remaining ones are rwx permissions for owner, group, and others, with letter indicating permission on, hyphen indicating permission off. Changing persmission: chmod \u003cuser type\u003e\u003cadd or remove\u003e\u003cpermission type\u003e. User type defaults to a. Example: chmod g+w adds write permission for group, chmod u-x removes execute permission for owner, chmod a+rwx grants all permission to everyone. chmod stands for change file mode bits. Shortcuts: Remember the following: Octal Binary 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 This is useful because we can use the binary numbers to refer to rwx and the Octal ones as shortcuts (e.g. 5 is r-x). Further using the order of users as ugo, and using one Octal shortcut for each user, we can quickly set permissions for all users (e.g. 753 is rwxr-x-wx). Directory permissions: r means you can read content (e.g. do ls), w means you can write (e.g. create files or subdirectories), and x means you can enter (e.g. cd). ","date":"2020-11-12","objectID":"/unix-basics/:4:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Shebang The shebang character sequence (#!) is used in the first line of a script to specify the interpreter that executes the commands in the script. There are two options, well explained here (and also, a bit more elaborately, here: one is the specify the absoute path to the interpreter (#!/bin/zsh), the other is to use the env utility to search for the specified interpreter in all directories in the $PATH variable and use the first occurrence that is found (#!/usr/bin/env zsh). The second option trades security for portability and is what most people seem to recommend. So this is what I use most of the time. ","date":"2020-11-12","objectID":"/unix-basics/:5:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Command-line utilities ","date":"2020-11-12","objectID":"/unix-basics/:6:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Getting help man Displays and formats the on-line manual pages. Invoke by typing man followed by the name of the command you want to know more about. info Displays and formats the entire documentation of a command. ","date":"2020-11-12","objectID":"/unix-basics/:6:1","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Searching fzf A command-line fuzzy finder that filters the results from a given input based on additional user input. For example, ls | fzf will display all files in the current directory and subdirectories, and then filter the results based on the user input. By default, it searches for files from the current directories. Advanced example uses here. I have created shortcuts that allow me to search and preview (with bat) all files in the current directory and subdirectories with fp (“file preview”), and do the same but then open the selected file with nvim with fv (“file vim”). grep and rg Searches for a pattern in a file or files. To find all markdown files in the current directory and subdirectories that contain the word “python”: grep -r --inlcude=\"*.md\" \"python\" . rg is a faster alternative to grep. find and fd find is a command-line utility that searches for files in a directory hierarchy. fd is a simple, fast and user-friendly alternative to find. ","date":"2020-11-12","objectID":"/unix-basics/:6:2","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"File manipulation awk A programming language designed for text processing and typically used as a data extraction and reporting tool (it takes its name from the initials of its three creators). It is a standard feature of most Unix-like operating systems, and particularly useful for processing text files. It operates on a line-by-line basis and splits each line into fields. For example, to print the first and second fields of each line of a file: awk '{print $1, $2}' file.txt sort Sorts lines of text files. For example, to sort the lines of a file in reverse order: sort -r file.txt uniq Filters adjacent matching lines from input. For example, to print only unique lines of a (sorted) file: uniq file.txt cat Concatenates files and prints on the standard output. For example, to print the contents of a file: cat file.txt sed A stream editor for filtering and transforming text. It reads text, line by line, from standard input and modifies it according to an expression, before outputting it again. For example, to replace all occurrences of “foo” with “bar” in a file: sed -i 's/foo/bar/g' file.txt To remove the first line of the input file: sed -i '1d' file.txt ","date":"2020-11-12","objectID":"/unix-basics/:6:3","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Process management ps ps stands for “process status” and, by default, shows all processes with controlling terminals. ","date":"2020-11-12","objectID":"/unix-basics/:6:4","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Miscellaneous eval Evaluates the arguments as a shell command. For example, to run the command ls -l: eval ls -l This is useful when you want to run a command that is stored in a variable: cmd=\"ls -l\" eval $cmd diff Compares files line by line. xargs A command-line utility that reads data from standard input and executes a command separately for each element in the input (by default, elements are separated by blanks). For example, to create directories ‘one’, ’two’, and ’three’: echo \"one two three\" | xargs mkdir Or, to delete all files in the current directory and subdirectories that contain the word “python”: grep -r --inlcude=\"*.md\" \"python\" . | xargs rm ","date":"2020-11-12","objectID":"/unix-basics/:6:5","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Custom scripts To practice the use of the command-line utilities, I have created a few custom scripts that I use on a regular basis. They are stored in my dotfiles repo. ","date":"2020-11-12","objectID":"/unix-basics/:7:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Kill processes by name Inspired by this post, I create a script to easily kill processes by name. #!/bin/zsh # A simple script to kill a process by name. Use [tab] to select # multiple processes and press [enter] to kill them or [esc] to cancel. local pid=$(ps -e | sed 1d | fzf -m --header='[kill:process]' | awk '{print $1}') if [[ -n \"$pid\" ]] then echo $pid | xargs kill else echo \"No process selected\" fi The script saves all selected processes in the variable pid and then kills them. $( expression ) saves the output of the entire expression in the variable pid. ps -e lists all processes (by default, only processes with controlling terminals are shown, so the -e flag is passed to show all processes). sed 1d removes the first line of the output (which contains the column names). fzf -m --header='[kill:process]' displays all processes in a fuzzy finder and allows the user to select multiple processes. awk '{print $1}' prints the first column of the output (which contains the process ids). The test condition evaluation utility [[ is used to check if the variable pid is not empty. This is achieved using the -n flag, which returns true if length of the following string is non-zero (see man test). echo $pid | xargs kill passes the selected process ids to the kill command one by one. ","date":"2020-11-12","objectID":"/unix-basics/:7:1","tags":null,"title":"Unix basics","uri":"/unix-basics/"},{"categories":["craft"],"content":"Resources Ryan’s bash-scripting tutorial Ryan’s linux tutorial ","date":"2020-11-12","objectID":"/unix-basics/:8:0","tags":null,"title":"Unix basics","uri":"/unix-basics/"}]